import { collection, getDocs, query, where } from "firebase/firestore";
import { userDataService } from "./user_data";
import { db } from "../firebase";
import { UserInfo } from "../models/UserInfo";
import { Review } from "../models/Review";

export class LabelingSessionService {
    countPlacesLabeled: number = 0;
    lastSessionTime: Date | null = null;
    startedAt: Date | null = null;
    canLabel: boolean = false;
    placesLabeledIds: string[];

    constructor() {
        this._setLastSessionAndCountPlacesLabeled();
        this.startedAt = new Date(Date.now());
        this.placesLabeledIds = [];
        this._getUserLabeledIds()
        .then((ids) => {
            this.placesLabeledIds = ids;
        });
    }

    static async instance() {
        const instance = new LabelingSessionService();
        await instance._setLastSessionAndCountPlacesLabeled();
        instance.placesLabeledIds = await instance._getUserLabeledIds() 
        return instance;
    }

    
    async _setLastSessionAndCountPlacesLabeled() {
        const userData = await userDataService.getUserInfo();
        const rawLastSession = userData?.last_session_at;
        const parsedDate = rawLastSession ? new Date(rawLastSession) : null;
    
        if (parsedDate && !isNaN(parsedDate.getTime())) {
            this.lastSessionTime = parsedDate;
        } else {
            console.warn("Invalid or missing last_session_at. Using current time as fallback.");
            this.lastSessionTime = new Date(); // fallback para agora
        }
        const lastSession = this.lastSessionTime.getTime();
        const currentTime = Date.now();
        const timeSinceLastSession = currentTime - lastSession;
        const twentyFourHours = 24 * 60 * 60 * 1000;
        const maxPlaces = 25;
    
        const hasBeen24Hours = timeSinceLastSession > twentyFourHours;
    
        if (hasBeen24Hours) {
            this.countPlacesLabeled = 0;
            this.canLabel = true;
        } else {
            this.countPlacesLabeled = typeof userData?.count_places_labeled_last_session === "number"
                ? userData.count_places_labeled_last_session
                : 0;
            this.canLabel = this.countPlacesLabeled < maxPlaces;
        }
    }
    
    
    async _getUserLabeledIds() : Promise<string[]> {
        const user = await userDataService.getUserInfo();
        const userId = user?.firebase_uid;

        try {
            const collectionRef = collection(db, "reviews");
            const q = query(collectionRef, where("reviewer_id", "==", userId));
            const snapshot = getDocs(q);
            const placesIds: string[] = []; 
            snapshot.then((querySnapshot) => {
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    if (data.place_id) {
                        placesIds.push(data.place_id);
                    }
                });
            })
            .finally(() => {
                return placesIds;
            });

            return [];
        } catch (error) {
            return [];
        }
    }

    addLabeledPlace(placeId: string) {
        this.placesLabeledIds.push(placeId);
        this.countPlacesLabeled += 1;
    }

    validateBeforeLabeling(placeId: string): boolean {
        if (!this.canLabel) {
            console.error("You have reached the maximum number of places you can label in this session.");
            return false;
        }
        if (this.placesLabeledIds.length >= 25) {
            console.error("You have already labeled this place.");
            return false;
        }
        if (this.placesLabeledIds.includes(placeId)) {
            console.error("You have already labeled this place.");
            return false;
        }
        return true;
    }

    async labelPlace(placeId: string, hasBeenThere: boolean, vibes: string[]): Promise<boolean> {
        if (!this.validateBeforeLabeling(placeId)) {
            return false;
        }

        this.addLabeledPlace(placeId);

        let user = await userDataService.getUserInfo();

        const now = new Date(Date.now());
        if (user!== null) {

            const updatedUser = await user.addReviewedPlace(placeId, this.startedAt ?? now, this.countPlacesLabeled);

            if(updatedUser){
                const newUser = await UserInfo.getFromDb(user.firebase_uid);

                newUser && userDataService.setUserInfo(newUser);

                const review = new Review(
                    '', // id will be generated by Firestore
                    user.firebase_uid,
                    placeId,
                    now,
                    vibes,
                    hasBeenThere
                );

                if(await review.sendToDb()){
                    console.log("Review sent to Firestore successfully.");
                    return true;
                }

                console.error("Error sending review to Firestore.");
                return false;
            }

            console.error("Error updating user info in Firestore.");
            return false;
            
        }

        console.error("User not found.");
        return false;
    }

    async skipPlace(placeId: string): Promise<void> {
        let user = await userDataService.getUserInfo();
        await user?.skipPlace(placeId);
    }
}